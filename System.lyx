#LyX 1.5.3 created this file. For more info see http://www.lyx.org/
\lyxformat 276
\begin_document
\begin_header
\textclass article
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\paperfontsize default
\spacing single
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\leftmargin 10page%
\topmargin 8pheight%
\bottommargin 8pheight%
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language swedish
\papercolumns 1
\papersides 1
\paperpagestyle default
\bullet 1 0 9 -1
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
CPSC 565 Term Project Development Guide
\end_layout

\begin_layout Author
Neil Tallim
\end_layout

\begin_layout Date
\begin_inset ERT
status inlined

\begin_layout Standard


\backslash
today
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard

\newpage

\end_layout

\begin_layout Part
Introduction
\end_layout

\begin_layout Section
Overview
\end_layout

\begin_layout Standard
What I am proposing as a term project is a system that simulates a terrarium,
 containing an arbitrary number of insect-like factions, loosely modeled
 after ant colonies, and a number of threats, which seek to eat the ant-like
 insects.
 This system will demonstrate the following features, all of which are modular
 and open to reimplementation and reimagination in the future to create
 a more accurate and interesting simulation (however, they are simplified
 right now because of time constraints):
\end_layout

\begin_layout Itemize
Agent reproduction and death
\end_layout

\begin_layout Itemize
Agent generation based on need
\end_layout

\begin_layout Itemize
Resource competition
\end_layout

\begin_layout Itemize
Survival behaviour
\end_layout

\begin_layout Itemize
Pathfinding
\end_layout

\begin_layout Itemize
Per-agent behaviour triggered by environmental hints
\end_layout

\begin_layout Section
Why this project idea was developed
\end_layout

\begin_layout Standard
The goal of this project is to provide the implementor with an understanding
 of how the workings of independent agents can affect, and even restructure,
 the operations of an entire culture.
 Additionally, the effects of tiny changes to the environment, such as the
 addition of a single wall space, a change in the rate of resource replenishment
, or an adjustment to the aggressiveness of a predator, will be studied
 to see how they cascade through the system and how all of the affected
 agents behave as a result.
\end_layout

\begin_layout Standard
This system will give insight into the nature of emergent patterns with
 multiple variables at play, via simulation of a liberal adaptation of a
 real-world system.
 The knowledge learned here will be applied to part of an extracurricular
 project currently being formulated.
\end_layout

\begin_layout Section
How this system will work
\end_layout

\begin_layout Standard
This system will run as a 0-player game with two main active layers: cellular
 automata to propagate signals like pheromones, and agents that interact
 with objects and each other, and which derive information from the cellular
 automata layer.
 (Note, however, that each layer is comprised of multiple elements, described
 in 
\begin_inset LatexCommand vref
reference "sub:Overview-technical"

\end_inset

) Every iteration (tick), the current state of the field will be evaluated
 and transformed to create the next state.
 Most information will be visible to the observer (user) in the form of
 statistics that may be viewed by pausing the simulation and investigating
 the properties of any object, and a graphical field rendition will show
 where everything in the system is in near-real-time.
\end_layout

\begin_layout Standard
A very early conceptual example of what this system might look like in a
 custom engine is presented below.
 However, the final system will likely be implemented using Breve on a strictly
 2D plane.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Standard
\noindent
\align center
\begin_inset Graphics
	filename proposal.png
	display none
	width 75col%

\end_inset


\begin_inset Caption

\begin_layout Standard
Early conceptual rendering of the system
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
How this system will work on a technical level
\begin_inset LatexCommand label
name "sub:Overview-technical"

\end_inset


\end_layout

\begin_layout Standard
To prevent the 
\begin_inset Quotes sld
\end_inset

turn order
\begin_inset Quotes srd
\end_inset

 of agents from being a factor when transitioning between iterations, each
 element of the field -- signals, entities, unts (the ant-like agents, see
 
\begin_inset LatexCommand vref
reference "sub:Unts"

\end_inset

), threats (see 
\begin_inset LatexCommand vref
reference "sub:Threats"

\end_inset

) -- will be discretely written to the new state-field in order.
 When writing the new state information, completed elements will be overlaid
 on the previous state-field (so unts will see the new signal map, but they
 won't see their neighbours' new positions) when updating.
\end_layout

\begin_layout Standard
All threats and all unts, as members of two isolated pools, will block on
 their movement events until all of their peers are ready; this will ensure
 that they all have fair views of the world around them before interacting
 with it.
 Lastly, threats need to move after unts so that they actually have a chance
 of killing them (this way, the threats will be able to move directly towards
 unts that may be trying to escape, giving them better attack vectors).
\end_layout

\begin_layout Subsection
How observers will interact with this system
\end_layout

\begin_layout Standard
This system will load configuration data that specifies global environment
 variables, referenced by all agents, and per-colony/threat-class environment
 variables that are referenced by specific entities.
 Additionally, configuration data specifying the size of the field and the
 location of objects within it will also be fully customizable.
\end_layout

\begin_layout Standard
All scenarios will be perfectly reproducible given the same input data,
 so to simplify the process of revisiting interesting developments, every
 time the system is started, a copy of all of its configuration data will
 be replicated.
 To remove the effects of entropy, the configuration options will include
 a parameter for seeding the RNG.
\end_layout

\begin_layout Standard
Live interaction is not currently planned, but it may be implemented on
 a level that allows, for example, walls to be added or removed.
\end_layout

\begin_layout Part
Components of the system
\end_layout

\begin_layout Standard

\emph on
Note: All logic is entirely unoptimized, and serves only as a reference
 for thought.
 The code samples provided are hardly production-quality, either -- in fact,
 they're procedural, which is definitely not how an implementation of a
 system like this should be written.
\end_layout

\begin_layout Section
Entities and agents
\end_layout

\begin_layout Standard
As an example of emergent logic, this system will be driven by its agents.
 However, there will be a minor degree of 
\begin_inset Quotes sld
\end_inset

external
\begin_inset Quotes srd
\end_inset

 organization, enforced by a quasi-elective governing system (the elective
 attributes come from the fact that all decisions will be made based on
 the existence of agents, and agents spawn and die over time in reaction
 to their environments).
\end_layout

\begin_layout Standard
On a basic level, the mobile objects within the system are its dominant
 agents, and the immobile ones are entirely inert agents that merely help
 to shape the environment around themselves.
 Entities are immobile agents that influence and react to the behaviour
 of the mobile agents around them, providing such logical features as intuitive,
 though non-explicit, waypoints in pathfinding, resource transportation
 infrastructure, and reproduction.
\end_layout

\begin_layout Standard
Put in practical, real-life-like terms, the mobile agents are things like
 ants and spiders, immobile agents are things like streams (walls), and
 entities are like food sources and ant nests that include queens.
\end_layout

\begin_layout Subsection
Unts
\begin_inset LatexCommand label
name "sub:Unts"

\end_inset


\end_layout

\begin_layout Standard
To cover the fact that this system will only be loosely based on the workings
 of ant colonies, the 
\begin_inset Quotes sld
\end_inset

protagonists
\begin_inset Quotes erd
\end_inset

 will be referred to as 'unts' (singular: unt, pronounced as 'unit').
\end_layout

\begin_layout Standard
Each class of unts that contains more than one role will have its roles
 assigned based on the rules in 
\begin_inset LatexCommand vref
reference "sec:Role-assignment"

\end_inset

.
\end_layout

\begin_layout Standard
There are several classes of unts planned for this system; these are described
 in the following sections.
\end_layout

\begin_layout Subsubsection
Workers
\end_layout

\begin_layout Standard
Workers are unts that, for their entire lifespans, repeatedly leave hills
 in search of resources, which they need to harvest for the sake of the
 colony's survival.
\end_layout

\begin_layout Standard
Notable traits include the following:
\end_layout

\begin_layout Itemize
Most workers will be attracted to harvesting signals (some may only want
 food and some may only want water, depending on the needs of the colony);
 however, some will be repelled by the signals of others, which will ensure
 that the colony will always search for new sources.
 (See 
\begin_inset LatexCommand vref
reference "sub:Stochastic-behaviour"

\end_inset

)
\end_layout

\begin_layout Itemize
Workers have a boldness property, which determines how they will behave
 when threats are around -- whether they will prioritize their own survival
 or act as martyrs to draw the attention of the colony's warriors.
\end_layout

\begin_layout Itemize
Workers will, when exploring for resources, never move towards the hill
 from which they originated until they have something to return.
 This will model semi-systematic behaviour and help to keep resources flowing.
\end_layout

\begin_layout Itemize
When a worker is carrying resources, it will return to the nearest accessible
 hill that belongs to its colony.
 This will help to spread unts based on regional need.
\end_layout

\begin_layout Itemize
Workers that are carrying resources will deposit pheromones on every space
 that they reach while heading to the nearest hill.
 (See 
\begin_inset LatexCommand vref
reference "sub:Pheremones"

\end_inset

)
\end_layout

\begin_layout Subsubsection
Builders
\end_layout

\begin_layout Standard
Builders are inside-workers, unts that reinforce the structure of a colony
 and hill.
 However, they exhibit no direct influence on anything in this simulation.
 Rather, they serve as a metric for evaluating how mature a hill is, allowing
 architects to be spawned (see 
\begin_inset LatexCommand vref
reference "sub:Architects"

\end_inset

), which allows new hills to be formed.
\end_layout

\begin_layout Standard
When a new hill is formed, the builders in the hill that 
\begin_inset Quotes sld
\end_inset

reproduced
\begin_inset Quotes srd
\end_inset

 will implicitly construct tunnels to the new location and set it up for
 use, then change their roles to those of workers and warriors as directed
 by the colony's current distribution rules (see 
\begin_inset LatexCommand vref
reference "sub:Assigning-classes"

\end_inset

) to settle it.
\end_layout

\begin_layout Subsubsection
Warriors
\end_layout

\begin_layout Standard
Warriors are unts that exist solely to protect workers.
\end_layout

\begin_layout Standard
If workers get slaughtered, their colony will have fewer resources, and
 threatened hills will become a liability.
 To prevent this, warriors serve in two roles:
\end_layout

\begin_layout Itemize
Escorts, which follow any gathering-related signal pheromones they sense,
 keeping threats away from supply lines.
\end_layout

\begin_layout Itemize
Patrollers, which disperse throughout a colony's 
\begin_inset Quotes sld
\end_inset

territory
\begin_inset Quotes srd
\end_inset

 and deter threats and invasions before they can become a problem.
\end_layout

\begin_layout Standard
All warriors will respond to any attack signals that they perceive, no matter
 what role they hold.
 This will ensure that threats are dealt with as rapidly as possible.
 (However, it might also lead to weaknesses in the colony's defenses, which
 could possibly allow other threats to enter.
 The implications of this behaviour are sure to be an interesting area of
 study)
\end_layout

\begin_layout Subsubsection
Architects
\begin_inset LatexCommand label
name "sub:Architects"

\end_inset


\end_layout

\begin_layout Standard
Architects are unts that have the sole task of finding an appropriate place
 to construct a new hill.
 They have above-average terrain awareness and no return-to-base logic,
 so they will just keep going until they find a suitable location or die
 trying (see 
\begin_inset LatexCommand vref
reference "sub:Expansion"

\end_inset

 for an explanation of why this suicidal behaviour is not a problem).
\end_layout

\begin_layout Standard
Unfortunately, architects are a necessary pacemaker (directing where expansion
 will occur, rather than letting it happen as a result of swarm consensus)
 due to the lack of time that can be dedicated to this project.
 However, they only replace one non-primary logical process, so their pacemaker
 effect is reasonably minimal overall.
\end_layout

\begin_layout Subsection
Unt colonies and hills
\end_layout

\begin_layout Standard
Unts exist as part of a colony, which consists of one or more hills and
 some information that describes the classes that make up its race.
 In fact, that's really all there is to the definition of a colony within
 this system: a collection of hills; collected, shared communal resources;
 the archetypes used to generate new unts; information about when to spawn
 a new generation.
 Colonies have no physical presence.
\end_layout

\begin_layout Standard
Hills are actual entities that offer shelter and pathfinding targets for
 unts, as well as locations where new unts will appear.
 However, beyond being gathering points, hills exert no control over how
 individual unts will behave.
\end_layout

\begin_layout Standard
Colonies and hills are effectively analogous to countries that consist of
 a number of cities, all of which are in a state of quasi-anarchy, with
 a decentralised government, yet which all freely share information and
 resources as needed, like a pure communism.
 So, while the placement of hills may have a dramatic impact on how colonies
 will evolve, they do not affect the more primitive patterns of the ecology
 in which their constituents live.
\end_layout

\begin_layout Subsection
Threats
\begin_inset LatexCommand label
name "sub:Threats"

\end_inset


\end_layout

\begin_layout Standard
Threats include anything that has the capacity to harm unts, including warrior
 unts from other colonies.
 Non-unt threats may be generically conceptualized as spiders or other predatory
 insects.
\end_layout

\begin_layout Standard
Each class of unt will take a different amount of time for non-unt threats
 to kill (unt threats attack and kill instantaneously).
 This is necessary to allow the defending colony's warriors time to react:
\end_layout

\begin_layout Itemize
Workers will take 
\begin_inset Formula $ENVIRONMENT_{KILL.TIME_{WORKER}}$
\end_inset

 iterations
\end_layout

\begin_layout Itemize
Warriors will take 
\begin_inset Formula $ENVIRONMENT_{KILL.TIME_{WARRIOR}}$
\end_inset

 iterations
\end_layout

\begin_layout Itemize
Architects will take 
\begin_inset Formula $ENVIRONMENT_{KILL.TIME_{ARCHITECT}}$
\end_inset

 iterations
\end_layout

\begin_layout Standard
After non-unt threats' lifespans have expired, depending on how many unts
 they consumed while alive, they will be survived by one or more of their
 kind:
\begin_inset Formula \[
children=floor(unts:consumed/ENVIRONMENT_{threat_{NOURISHMENT}})+1\]

\end_inset


\end_layout

\begin_layout Standard
Non-unt threats will not target each other.
\end_layout

\begin_layout Subsubsection
Predators
\end_layout

\begin_layout Standard
Predators are simple agents that randomly wander the field, looking for
 unts to kill.
 They will run away from attack pheromones to avoid their own demise.
 They will attack any unt that happens to enter their sight as long as,
 up 'til the time of the kill, the set of all unts they can see, excluding
 their target victim, is free of warriors.
\end_layout

\begin_layout Subsubsection
Hunters
\end_layout

\begin_layout Standard
Hunters behave just like predators, except they will emit random resource
 pheromones to lure workers to them.
 They will stop emitting pheromones upon selecting a victim, and they will
 only resume the process of depositing them once they have resumed wandering
 the field.
 (In terms of behavioural states (see 
\begin_inset LatexCommand vref
reference "sub:Behaviour"

\end_inset

), they deposit pheromones only while wandering)
\end_layout

\begin_layout Subsubsection
Stalkers
\end_layout

\begin_layout Standard
Stalkers behave just like predators, except they will respond to resource
 pheromones, which should lead them towards paths that are travelled by
 workers.
\end_layout

\begin_layout Subsection
Obstacles
\end_layout

\begin_layout Standard
Obstacles are any objects on the field that are not hostile to unts, but
 which impede movement or senses in some fashion.
\end_layout

\begin_layout Subsubsection
Walls
\end_layout

\begin_layout Standard
A wall is a space through which physical movement and pheromone detection
 are impossible.
 The effect of these objects is three-fold:
\end_layout

\begin_layout Enumerate
Objects on the other side of walls cannot be detected, even if they're within
 the agent's sight radius.
\end_layout

\begin_layout Enumerate
Signals on the other side of walls cannot be detected, even if they're within
 the agent's smell radius.
\end_layout

\begin_layout Enumerate
Unts will need to apply special pathfinding rules (see 
\begin_inset LatexCommand vref
reference "sub:Pathfinding"

\end_inset

) to find ways around walls, especially when heading back to their colony.
\end_layout

\begin_layout Subsubsection
Sponges
\end_layout

\begin_layout Standard
A sponge does not impede physical movement, but it will absorb all pheromones
 that reach it.
 However, sight through sponges will not be affected.
 They are, essentially, walls that do not carry the first and third impacts.
\end_layout

\begin_layout Subsection
Resources
\end_layout

\begin_layout Standard
Resources are required for a colony to survive.
 The primary goal of any colony is securing additional resources and growing
 as much as possible.
\end_layout

\begin_layout Standard
Neither food nor water is inherently more valuable than its counterpart.
 However, availability and consumption properties can easily change the
 priority of either as a simulation progresses.
\end_layout

\begin_layout Subsubsection
Food
\end_layout

\begin_layout Standard
Food is one of two resources required for a colony to survive.
 It appears in the field as a single entity that has a maximum quantity
 value (
\begin_inset Formula $food_{CAPACITY}$
\end_inset

), which is replenished by 
\begin_inset Formula $food_{REPLENISHMENT}*food_{CAPACITY}$
\end_inset

 every 
\begin_inset Formula $food_{COOLDOWN}$
\end_inset

 iterations.
\end_layout

\begin_layout Subsubsection
Water
\end_layout

\begin_layout Standard
Water is the second of two resources required for a colony to survive.
 It appears in the field as a single entity that has a maximum quantity
 value (
\begin_inset Formula $water{}_{CAPACITY}$
\end_inset

), which is replenished by 
\begin_inset Formula $water{}_{REPLENISHMENT}*water{}_{CAPACITY}$
\end_inset

 every 
\begin_inset Formula $water{}_{COOLDOWN}$
\end_inset

 iterations.
\end_layout

\begin_layout Section
Role assignment
\begin_inset LatexCommand label
name "sec:Role-assignment"

\end_inset


\end_layout

\begin_layout Standard
This section describes how unts receive the roles and properties that govern
 their behaviour in the field.
\end_layout

\begin_layout Subsection
Worker roles
\end_layout

\begin_layout Standard
Workers are responsible for gathering food and water to keep their colony
 alive.
 Depending on need, the number of workers assigned to either task may be
 disproportionate, or workers may be told to find whatever resource they
 can.
\end_layout

\begin_layout Standard
Note that some workers may exhibit stochastic behaviour, which will cause
 them to distance themselves from known supply paths.
 However, their priorities will remain the same.
\end_layout

\begin_layout Subsubsection
Seeking food
\end_layout

\begin_layout Standard
Food-seekers will react to food-related pheromone signals and food resources,
 heading towards these leads to begin harvesting so they can return what
 they can find to the nearest hill.
\end_layout

\begin_layout Standard
If they reach a depleted resource, they will try to find an alternative.
\end_layout

\begin_layout Subsubsection
Seeking water
\end_layout

\begin_layout Standard
Water-seekers will react to water-related pheromone signals and water resources,
 heading towards these leads to begin harvesting so they can return what
 they can find to the nearest hill.
\end_layout

\begin_layout Standard
If they reach a depleted resource, they will try to find an alternative.
\end_layout

\begin_layout Subsubsection
Seeking any resource
\end_layout

\begin_layout Standard
These workers will react to any resource-related pheromone signals or resource
 sites, bringing whatever they can find back to the nearest hill.
 To other unts, they will appear to be seekers of either food or water;
 the only difference is that these types of unts will be of much more use
 in establishing local patterns around new hills because they will swarm
 on resources much more readily.
\end_layout

\begin_layout Standard
If they reach a depleted resource, they will try to find another.
\end_layout

\begin_layout Subsubsection
Role assignment
\end_layout

\begin_layout Standard
When a state transition occurs, any workers in a hill will be dispatched.
 At this point, each worker will individually receive a role based on whether
 the colony would be in danger of running out of one type of resource if
 all of its unts were to feed at the same time (by determining whether such
 an event would lead to the starvation of any unts, were it to happen twice):
\end_layout

\begin_layout Itemize
\begin_inset Formula $consumption_{food}=\sum colony_{unts{}_{consumption:food}}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $consumption_{water}=\sum colony_{unts{}_{consumption:water}}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $risk_{food}=-(colony_{food:available}-(consumption_{food}*2))$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $risk_{water}=-(colony_{water:available}-(consumption_{water}*2))$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize},language=Python"
inline false
status open

\begin_layout Standard

i = unt_being_evaluated
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

if risk.food <= 0 and risk.water <= 0: #No risk.
\end_layout

\begin_layout Standard

 if random.random() < ENVIRONMENT.colony.WORKER.NO_FOCUS:
\end_layout

\begin_layout Standard

  i.role = None
\end_layout

\begin_layout Standard

 else:
\end_layout

\begin_layout Standard

  i.role = random.choice((ENUMERATIONS.FOOD, ENUMERATIONS.WATER))
\end_layout

\begin_layout Standard

elif risk.food > 0 and risk.water > 0: #Dire risk.
\end_layout

\begin_layout Standard

 if random.random() < risk.food / (risk.food + risk.water): #Proportional bias
 to the weaker supply.
\end_layout

\begin_layout Standard

  i.role = ENUMERATIONS.FOOD
\end_layout

\begin_layout Standard

 else:
\end_layout

\begin_layout Standard

  i.role = ENUMERATIONS.WATER
\end_layout

\begin_layout Standard

elif risk.food > 0: #Low food.
\end_layout

\begin_layout Standard

 if random.random() < (risk.food / consumption.food):
\end_layout

\begin_layout Standard

  i.role = ENUMERATIONS.FOOD
\end_layout

\begin_layout Standard

 else:
\end_layout

\begin_layout Standard

  i.role = random.choice((ENUMERATIONS.WATER, None))
\end_layout

\begin_layout Standard

elif risk.water > 0: #Low water.
\end_layout

\begin_layout Standard

 if random.random() < (risk.water / consumption.water):
\end_layout

\begin_layout Standard

  i.role = ENUMERATIONS.WATER
\end_layout

\begin_layout Standard

 else:
\end_layout

\begin_layout Standard

  i.role = random.choice((ENUMERATIONS.FOOD, None))
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Stochastic behaviour
\begin_inset LatexCommand label
name "sub:Stochastic-behaviour"

\end_inset


\end_layout

\begin_layout Standard
Each worker has a 
\begin_inset Formula $ENVIRONMENT_{colony_{WORKER{}_{STOCHASTIC.PROBABILITY}}}$
\end_inset

 chance of being a stochastic element.
 This property is assigned when the unt is created.
\end_layout

\begin_layout Subsection
Warrior roles
\end_layout

\begin_layout Standard
Warriors are responsible for keeping a colony's workers safe, ensuring that
 they can gather vital resources and explore the colony's 
\begin_inset Quotes sld
\end_inset

territory
\begin_inset Quotes srd
\end_inset

 to find new resources and suitable locations for expansion.
\end_layout

\begin_layout Subsubsection
Escorting workers
\end_layout

\begin_layout Standard
Escorts try to stay near supply paths by following the pheromones they sense.
 In this role, they will help to prevent threats from disrupting the most
 vital behaviour of their colony because threats will stay away if they
 notice that the swarm is well-protected.
\end_layout

\begin_layout Subsubsection
Patrolling territory
\end_layout

\begin_layout Standard
Patrollers offer a means of guarding a colony's territory.
 They will spread out from the outlying hills of their colonies and disperse
 to shape a perimeter that will deter invasion by threats and other colonies.
\end_layout

\begin_layout Subsubsection
Role assignment
\end_layout

\begin_layout Standard
Upon creation, each unt will have a 
\begin_inset Formula $ENVIRONMENT_{colony_{WARRIOR_{ESCORT}}}$
\end_inset

 chance of being an escort, rather than a patroller.
\end_layout

\begin_layout Section
Simulation rules
\end_layout

\begin_layout Standard
These are rules that cannot be changed by configuration variables.
 While they may be adaptive and react according to the influences of configurati
on variables, they cannot be directly altered.
\end_layout

\begin_layout Standard
These rules are what govern how this simulation is unique.
\end_layout

\begin_layout Subsection
Unt energy rules
\end_layout

\begin_layout Standard
Each class of unt for each colony has a certain amount of energy, like stamina,
 that determines how long it can survive before eating again.
\end_layout

\begin_layout Standard
Each iteration, each unt's remaining energy will decrease by one.
\end_layout

\begin_layout Standard
All workers will make returning to base their top priority when their energy
 has fallen to 50%.
 All warriors will do the same, unless they are in pursuit of a threat,
 since protecting workers takes precedence over their own lives.
 Builders, never leaving their hills, will ignore their energy level until
 it hits 0%.
\end_layout

\begin_layout Standard
If an unt is outside of a hill (or it is a starved builder) when its energy
 hits 0%, it dies instantly.
\end_layout

\begin_layout Subsubsection
Energy recovery
\begin_inset LatexCommand label
name "sub:Energy-recovery"

\end_inset


\end_layout

\begin_layout Standard
Whenever an unt leaves a hill (or whenever a builder's energy hits 0%),
 it eats to replenish its strength; this is done by consuming its colony's
 resources.
 The following algorithm explains how this works.
 Note that it is quite simple, and it allows for some fuzziness because
 accuracy here is not terribly important, at least relative to the overhead
 that would be required to deal with whether one unt eats or not.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize},language=Python"
inline false
status collapsed

\begin_layout Standard

i = unt_being_evaluated
\end_layout

\begin_layout Standard

restored_halves = 0
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

if colony.resources(ENUMERATIONS.FOOD) > 0:
\end_layout

\begin_layout Standard

 colony.resources(ENUMERATIONS.FOOD) -= 
\backslash

\end_layout

\begin_layout Standard

  i.consumption(ENUMERATIONS.FOOD) * (1 - (i.remaining_energy / i.max_energy))
\end_layout

\begin_layout Standard

 restored_halves += 1
\end_layout

\begin_layout Standard

 if colony.resources(ENUMERATIONS.FOOD) < 0:
\end_layout

\begin_layout Standard

  colony.resources(ENUMERATIONS.FOOD) = 0
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

if colony.resources(ENUMERATIONS.WATER) > 0:
\end_layout

\begin_layout Standard

 colony.resources(ENUMERATIONS.WATER) -= 
\backslash

\end_layout

\begin_layout Standard

  i.consumption(ENUMERATIONS.WATER) * (1 - (i.remaining_energy / i.max_energy))
\end_layout

\begin_layout Standard

 restored_halves += 1
\end_layout

\begin_layout Standard

 if colony.resources(ENUMERATIONS.WATER) < 0:
\end_layout

\begin_layout Standard

  colony.resources(ENUMERATIONS.WATER) = 0
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

i.remaining_energy += ((1 - (i.remaining_energy / i.max_energy)) / 2) * restored_ha
lves
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Behavioural triggers
\begin_inset LatexCommand label
name "sub:Behaviour"

\end_inset


\end_layout

\begin_layout Standard
This section describes how agents in the system will alter their behaviour
 based on things they detect in the field.
\end_layout

\begin_layout Subsubsection
Workers
\end_layout

\begin_layout Standard
Workers operate in one of two basic modes: wandering and harvesting.
 When wandering, also referred to as exploring, workers will move about
 the field, trying not to approach the hill from which they departed.
 When harvesting, which is triggered by any lead that hints at the presence
 of resources that they seek, they will close in on the lead until they
 either reach the resource or lose track of it.
 Upon reaching a resource, they will return directly to their hill with
 as much of it as they can carry in tow.
\end_layout

\begin_layout Standard
To make this system interesting, some workers exhibit non-social behaviour,
 as stochastic elements, which causes them to actively avoid known resources
 in hopes of discovering new ones.
\end_layout

\begin_layout Standard
Workers also have the curious property of aggression: depending on the nature
 of the colony, workers may exhibit varying degrees of aggressiveness, which
 will dictate whether they will seek to initiate combat, directing the colony's
 warriors to areas where they are needed, or whether they will run to safety,
 keeping the number of worker deaths down at the cost of productivity.
\end_layout

\begin_layout Standard

\series bold
Behavioural logic
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize},language=Python"
inline false
status collapsed

\begin_layout Standard

i = unt_being_evaluated
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

#Clear unneeded avoidances.
\end_layout

\begin_layout Standard

for avoid in i.getAvoidances():
\end_layout

\begin_layout Standard

 if not i.canSense(avoid):
\end_layout

\begin_layout Standard

  i.clearAvoidance(avoid)
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

if i.status == ENUMERATIONS.FOLLOWING:
\end_layout

\begin_layout Standard

 if not exists(i.target):
\end_layout

\begin_layout Standard

  i.status = ENUMERATIONS.WANDERING
\end_layout

\begin_layout Standard

  
\end_layout

\begin_layout Standard

if i.status == ENUMERATIONS.WANDERING or (i.status == ENUMERATIONS.FOLLOWING
 and isSignal(i.target)):
\end_layout

\begin_layout Standard

 suicide_run = False #Used to prevent distractions while charging a threat.
\end_layout

\begin_layout Standard

 threats = [agent <- i.agentsInLoS() | isThreat(i, agent)]
\end_layout

\begin_layout Standard

 if threats:
\end_layout

\begin_layout Standard

  if i.aggression == ENUMERATIONS.BOLDNESS.AGGRESSIVE:
\end_layout

\begin_layout Standard

   i.follow(threats[0]) #Switches to following.
\end_layout

\begin_layout Standard

   i.clearAvoidances() #Make the path straight.
\end_layout

\begin_layout Standard

   suicide_run = True
\end_layout

\begin_layout Standard

  elif i.aggression == ENUMERATIONS.BOLDNESS.ASSERTIVE:
\end_layout

\begin_layout Standard

   pass #Whatever happens happens.
\end_layout

\begin_layout Standard

  elif i.aggression == ENUMERATIONS.BOLDNESS.PASSIVE:
\end_layout

\begin_layout Standard

   i.avoid(threats[0]) #Doesn't change state, but affects pathfinding.
\end_layout

\begin_layout Standard

 
\end_layout

\begin_layout Standard

 if not suicide_run: #Not charging a threat.
\end_layout

\begin_layout Standard

  threat_signals = [signal <- i.signalsInLoS() | signalType(signal) == ENUMERATIO
NS.THREAT]
\end_layout

\begin_layout Standard

  food_signals = [signal <- i.signalsInLoS() | signalType(signal) == 
\backslash

\end_layout

\begin_layout Standard

   ENUMERATIONS.FOOD, -90 < abs(angleOffset(i, i.nearestHill()) - angleOffset(i,
 signal)) > 90]
\end_layout

\begin_layout Standard

  water_signals = [signal <- i.signalsInLoS() | signalType(signal) == 
\backslash

\end_layout

\begin_layout Standard

   ENUMERATIONS.WATER, -90 < abs(angleOffset(i, i.nearestHill()) - angleOffset(i,
 signal)) > 90]]
\end_layout

\begin_layout Standard

  if threat_signals:
\end_layout

\begin_layout Standard

   i.avoid(strongestSignal(threat_signals)) #Doesn't change state, but affects
 pathfinding.
\end_layout

\begin_layout Standard

  if i.role == ENUMERATIONS.FOOD:
\end_layout

\begin_layout Standard

   if food_signals:
\end_layout

\begin_layout Standard

    if not i.isStochastic():
\end_layout

\begin_layout Standard

     i.follow(strongestSignal(food_signals)) #Switches to following.
\end_layout

\begin_layout Standard

    else:
\end_layout

\begin_layout Standard

     i.avoid(strongestSignal(food_signals)) #Affects pathfinding.
\end_layout

\begin_layout Standard

  elif i.role == ENUMERATIONS.WATER:
\end_layout

\begin_layout Standard

   if water_signals:
\end_layout

\begin_layout Standard

    if not i.isStochastic():
\end_layout

\begin_layout Standard

     i.follow(strongestSignal(water_signals)) #Switches to following.
\end_layout

\begin_layout Standard

    else:
\end_layout

\begin_layout Standard

     i.avoid(strongestSignal(water_signals)) #Affects pathfinding.
\end_layout

\begin_layout Standard

  else:
\end_layout

\begin_layout Standard

   if food_signals or water_signals:
\end_layout

\begin_layout Standard

    if not i.isStochastic():
\end_layout

\begin_layout Standard

     i.follow(strongestSignal(food_signals + water_signals)) #Switches to
 following.
\end_layout

\begin_layout Standard

    else:
\end_layout

\begin_layout Standard

     i.avoid(strongestSignal(food_signals + water_signals)) #Affects pathfinding.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

i.move() #Update position.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

if i.status == ENUMERATIONS.RETURNING: #Deposit appropriate pheremones.
\end_layout

\begin_layout Standard

 i.producePheremone(resourceType(i.carrying))
\end_layout

\begin_layout Standard

else:
\end_layout

\begin_layout Standard

 food = [resource <- i.resourcesInLoS() | resourceType(resource) == ENUMERATIONS.F
OOD]
\end_layout

\begin_layout Standard

 water = [resource <- i.resourcesInLoS() | resourceType(resource) == ENUMERATIONS.
WATER]
\end_layout

\begin_layout Standard

 
\end_layout

\begin_layout Standard

 if i.role == ENUMERATIONS.FOOD:
\end_layout

\begin_layout Standard

  if food:
\end_layout

\begin_layout Standard

   if distance(i, food[0]) == 1:
\end_layout

\begin_layout Standard

    if i.harvest(food[0]):
\end_layout

\begin_layout Standard

    i.status = ENUMERATIONS.RETURNING #Switches to returning.
\end_layout

\begin_layout Standard

     i.clearAvoidances()
\end_layout

\begin_layout Standard

    else:
\end_layout

\begin_layout Standard

     i.avoid(food[0]) #Look for another source.
\end_layout

\begin_layout Standard

     i.status = ENUMERATIONS.WANDERING #Switches to wandering.
\end_layout

\begin_layout Standard

   else:
\end_layout

\begin_layout Standard

    i.follow(food[0]) #Switches to following.
\end_layout

\begin_layout Standard

 elif i.role == ENUMERATIONS.WATER:
\end_layout

\begin_layout Standard

  if water:
\end_layout

\begin_layout Standard

   if distance(i, water[0]) == 1:
\end_layout

\begin_layout Standard

    if i.harvest(water[0]):
\end_layout

\begin_layout Standard

     i.status = ENUMERATIONS.RETURNING #Switches to returning.
\end_layout

\begin_layout Standard

     i.clearAvoidances()
\end_layout

\begin_layout Standard

    else:
\end_layout

\begin_layout Standard

     i.avoid(water[0]) #Look for another source.
\end_layout

\begin_layout Standard

     i.status = ENUMERATIONS.WANDERING #Switches to wandering.
\end_layout

\begin_layout Standard

   else:
\end_layout

\begin_layout Standard

    i.follow(water[0]) #Switches to following.
\end_layout

\begin_layout Standard

 else:
\end_layout

\begin_layout Standard

  if food or water:
\end_layout

\begin_layout Standard

   if distance(i, (food + water)[0]) == 1:
\end_layout

\begin_layout Standard

    if i.harvest((food + water)[0]):
\end_layout

\begin_layout Standard

     i.status = ENUMERATIONS.RETURNING #Switches to returning.
\end_layout

\begin_layout Standard

     i.clearAvoidances()
\end_layout

\begin_layout Standard

    else:
\end_layout

\begin_layout Standard

     i.avoid((food + water)[0]) #Look for another source.
\end_layout

\begin_layout Standard

     i.status = ENUMERATIONS.WANDERING #Switches to wandering.
\end_layout

\begin_layout Standard

   else:
\end_layout

\begin_layout Standard

    i.follow((food + water)[0]) #Switches to following.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Warriors
\end_layout

\begin_layout Standard
Any warrior will attack the closest threat within range.
 This applies to any warriors that are patrolling or escorting.
\end_layout

\begin_layout Standard
Threats that are active (fellow unts are attacking them or they have attacked
 a fellow unt) will be located based on pheromone signals and sight.
\end_layout

\begin_layout Standard

\series bold
Behavioural logic
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize},language=Python"
inline false
status collapsed

\begin_layout Standard

i = unt_being_evaluated
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

if i.status == ENUMERATIONS.FOLLOWING:
\end_layout

\begin_layout Standard

 if not exists(i.target):
\end_layout

\begin_layout Standard

  i.status = ENUMERATIONS.WANDERING
\end_layout

\begin_layout Standard

  
\end_layout

\begin_layout Standard

if i.status in (ENUMERATIONS.WANDERING, ENUMERATIONS.FOLLOWING):
\end_layout

\begin_layout Standard

 threats = [agent <- i.agentsInLoS() | isThreat(i, agent)]
\end_layout

\begin_layout Standard

 if threats:
\end_layout

\begin_layout Standard

  i.follow(threats[0]) #Switches to following.
\end_layout

\begin_layout Standard

 else: #Check pheremones.
\end_layout

\begin_layout Standard

  threats = [signal <- i.signalsInLoS() | signalType(signal) == ENUMERATIONS.THREA
T]
\end_layout

\begin_layout Standard

  if threats:
\end_layout

\begin_layout Standard

   i.follow(strongestSignal(threats)) #Switches to following.
\end_layout

\begin_layout Standard

  else:
\end_layout

\begin_layout Standard

   if i.role == ENUMERATIONS.ESCORT: #Stay near worker trails.
\end_layout

\begin_layout Standard

    signals = [signal <- i.signalsInLoS() | signalType(signal) in (ENUMERATIONS.FO
OD, ENUMERATIONS.WATER)]
\end_layout

\begin_layout Standard

    if signals:
\end_layout

\begin_layout Standard

     i.follow(strongestSignal(signals)) #Switches to following.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

i.move() #Update position.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

if i.status == ENUMERATIONS.FOLLOWING and isAgent(i.target):
\end_layout

\begin_layout Standard

 if distance(i, i.target) <= 1:
\end_layout

\begin_layout Standard

   i.attack(i.target) #May be a suicide attack to inflict damage.
\end_layout

\begin_layout Standard

   if i.isAlive(): #Won and survived.
\end_layout

\begin_layout Standard

    i.status = ENUMERATIONS.RETURNING #Go back to base and recover.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Architects
\end_layout

\begin_layout Standard
Architects just move until they find a suitable building location.
 This is determined by proximity to resources and distance from hills (architect
s can sense friendly hills 
\begin_inset Formula $2r$
\end_inset

 away, where 
\begin_inset Formula $r$
\end_inset

 is the radius of their resource-sensing capabilities.
 This will prevent two hills from focusing on the same resource).
\end_layout

\begin_layout Standard
When moving, architects always move away from their base hill.
\end_layout

\begin_layout Standard

\series bold
Behavioural logic
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize},language=Python"
inline false
status collapsed

\begin_layout Standard

i = unt_being_evaluated
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

i.move() #Update position.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

#Make sure there are no hills nearby.
\end_layout

\begin_layout Standard

if not [hill <- i.colony.hills | distance(i, hill) < ENVIRONMENT.MIN_BUILD_DISTANCE
]:
\end_layout

\begin_layout Standard

 #Check to see whether food or water is preferred and build if in range.
\end_layout

\begin_layout Standard

 food_sources = [resource <- i.resourcesInLoS() | resourceType(resource)
 == ENUMERATIONS.FOOD]
\end_layout

\begin_layout Standard

 water_sources = [resource <- i.resourcesInLoS() | resourceType(resource)
 == ENUMERATIONS.WATER]
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

 if i.role == ENUMERATIONS.FOOD:
\end_layout

\begin_layout Standard

  if food_sources:
\end_layout

\begin_layout Standard

   i.build() #Ends life.
\end_layout

\begin_layout Standard

 elif i.role == ENUMERATIONS.WATER:
\end_layout

\begin_layout Standard

  if water_sources:
\end_layout

\begin_layout Standard

   i.build() #Ends life.
\end_layout

\begin_layout Standard

 elif food_sources or water_sources:
\end_layout

\begin_layout Standard

  i.build() #Ends life.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Threats
\end_layout

\begin_layout Standard
When a threat is on the prowl, it will choose any available prey by applying
 rules similar to the unts' warrior algorithm.
 If it finds no prey, it will behave according to whatever is normal for
 its species (see 
\begin_inset LatexCommand vref
reference "sub:Threats"

\end_inset

).
\end_layout

\begin_layout Standard
Escaping, target-following, and attacking threats will not exhibit pheromone-bas
ed behaviour.
 Note that threats that follow signals will only go towards concentration
 points to keep them near prey paths, but they will not sit directly on
 prey paths (to avoid escorting warriors).
\end_layout

\begin_layout Standard

\series bold
Behavioural logic
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize},language=Python"
inline false
status collapsed

\begin_layout Standard

i = threat_being_evaluated
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

if i.status == ENUMERATIONS.WANDERING:
\end_layout

\begin_layout Standard

 prey = [agent <- i.agentsInLoS() | isUnt(agent)]
\end_layout

\begin_layout Standard

 if len(prey) == 1:
\end_layout

\begin_layout Standard

  i.attack(prey[0]) #Nothing threatening nearby.
\end_layout

\begin_layout Standard

 elif len(prey) > 1:
\end_layout

\begin_layout Standard

  if not containsWarrior(prey[1:]): #Make sure there's nothing threatening.
\end_layout

\begin_layout Standard

   i.follow(prey[0]) #Sets status to following.
\end_layout

\begin_layout Standard

elif i.status == ENUMERATIONS.FOLLOWING:
\end_layout

\begin_layout Standard

 if exists(i.target):
\end_layout

\begin_layout Standard

  threats = [agent <- i.agentsInLoS() | not agent == i.target and isWarrior(agent)
]
\end_layout

\begin_layout Standard

  if threats:
\end_layout

\begin_layout Standard

    i.status = ENUMERATIONS.WANDERING #Abandon the hunt.
\end_layout

\begin_layout Standard

 else:
\end_layout

\begin_layout Standard

  i.status = ENUMERATIONS.WANDERING
\end_layout

\begin_layout Standard

elif i.status == ENUMERATIONS.KILLING:
\end_layout

\begin_layout Standard

 i.progressKill() #Count down the ticks until movement is possible.
 Switches to retreating when done.
\end_layout

\begin_layout Standard

elif i.status == ENUMERATIONS.RETREATING: #While retreating, movement is straight.
\end_layout

\begin_layout Standard

 if signalStrength(i.location, THREAT) == 0:
\end_layout

\begin_layout Standard

  i.status = ENUMERATIONS.WANDERING #Safe enough.
\end_layout

\begin_layout Standard

 else:
\end_layout

\begin_layout Standard

  threats = [agent <- i.agentsInLoS() | isThreat(i, agent)]
\end_layout

\begin_layout Standard

  if threats: #Retreat from the closest one.
\end_layout

\begin_layout Standard

   i.rotate(angleOffset(i, threats[0]) + 180) #Run directly away from the
 nearest threat.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

i.move() #Update location.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

if i.status == ENUMERATIONS.FOLLOWING:
\end_layout

\begin_layout Standard

 if not isSignal(i.target):
\end_layout

\begin_layout Standard

  if distance(i, i.target) <= 2:
\end_layout

\begin_layout Standard

   i.kill(i.target) #Sets status to killing.
\end_layout

\begin_layout Standard

elif i.status == ENUMERATIONS.WANDERING and species(i) == Stalker:
\end_layout

\begin_layout Standard

 leads = [signals <- i.signalsInLoS() | signalType(signal) in (ENUMERATIONS.FOOD,
 ENUEMRATIONS.WATER)]
\end_layout

\begin_layout Standard

 if leads:
\end_layout

\begin_layout Standard

  i.follow(strongestSignal(leads)) #Sets status to following.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Pheromones
\begin_inset LatexCommand label
name "sub:Pheremones"

\end_inset


\end_layout

\begin_layout Standard
Pheromones, also referred to as signals, are a medium by which information
 about the field and its agents can travel.
 They offer an imprecise method of directing agents towards areas of interest.
\end_layout

\begin_layout Standard
Each space may have any quantity of any number of different pheromones;
 they do not interfere with one another.
\end_layout

\begin_layout Standard
Each colony produces its own set of pheromones that are meaningless to every
 other colony; threats produce and follow pheromones in a colony-independent
 manner.
\end_layout

\begin_layout Standard
Every unt has the ability to sense pheromones nearby, just as they can sense
 agents.
 An unt does not necessarily need to be in physical contact with pheromones,
 unless it has a sensing range of 0.
\end_layout

\begin_layout Subsubsection
Dispersion
\end_layout

\begin_layout Standard
Every cycle, the pheromones in each space will weaken, and the pheromones
 in adjacent spaces will increase slightly, until the concentration is too
 weak to persist.
 Pheromones strength will degrade according to the following formula:
\begin_inset Formula \[
strength_{new}=floor(strength_{old}*ENVIRONMENT{}_{SIGNALS_{DISPERSION.FACTOR}})\]

\end_inset


\end_layout

\begin_layout Standard
At the same time, based on the old strength of the pheromone, every surrounding
 space in the surrounding von Neumann neighbourhood will be given a quantity
 of the pheromone based on the following formula:
\begin_inset Formula \[
strength=floor(strength_{source}*ENVIRONMENT{}_{SIGNALS_{SPREAD.FACTOR..NEUMANN}})\]

\end_inset

Lastly, every non-overlapping space in the Moore neighbourhood will be given
 a quantity of the pheromone based on this formula:
\begin_inset Formula \[
strength=floor(strength_{source}*ENVIRONMENT{}_{SIGNALS_{SPREAD.FACTOR.MOORE}})\]

\end_inset


\end_layout

\begin_layout Subsubsection
Accumulation
\end_layout

\begin_layout Standard
Because pheromones have the potential to spread, they will collide in practice,
 and this, naturally, will cause them to become more intense.
 The following formula deals with this property, based on a list, 
\begin_inset Formula $signals$
\end_inset

, of all pheromones that hit any given space during the current cycle transition
:
\begin_inset Formula \[
strength=floor(max(signals)+\sum[ENVIRONMENT{}_{SIGNALS_{COLLISION.FACTOR}}*(signals-max(signals))])\]

\end_inset


\end_layout

\begin_layout Standard
This means that the strongest pheromone is used as the space's base, then
 a fraction of every other pheromone is added to it to get reasonable results.
\end_layout

\begin_layout Subsubsection
Food pheromones
\end_layout

\begin_layout Standard
Food pheromones are dropped by worker unts who are carrying food back to
 a hill.
 Every cycle, a concentration of 
\begin_inset Formula $ENVIRONMENT_{colony_{PHEREMONES}}$
\end_inset

 is deposited in the unt's current space.
\end_layout

\begin_layout Standard
Threats may deposit 
\begin_inset Formula $ENVIRONMENT_{HUNTERS_{PHEREMONES}}$
\end_inset

 each cycle, if they are hunters.
\end_layout

\begin_layout Subsubsection
Water pheromones
\end_layout

\begin_layout Standard
Water pheromones are dropped by worker unts who are carrying water back
 to a hill.
 Every cycle, a concentration of 
\begin_inset Formula $ENVIRONMENT_{colony_{PHEREMONES}}$
\end_inset

 is deposited in the unt's current space.
\end_layout

\begin_layout Standard
Threats may deposit 
\begin_inset Formula $ENVIRONMENT_{HUNTERS_{PHEREMONES}}$
\end_inset

 each cycle, if they are hunters.
\end_layout

\begin_layout Subsubsection
Attack pheromones
\end_layout

\begin_layout Standard
Attack pheromones are left behind whenever any unt is killed.
 They alert other unts to the presence of danger.
\end_layout

\begin_layout Standard
\begin_inset Formula $ENVIRONMENT_{colony_{PHEREMONES.ATTACK}}$
\end_inset

 will be dropped on the space of the agent that killed the unt.
\end_layout

\begin_layout Subsection
Pathfinding and movement
\begin_inset LatexCommand label
name "sub:Pathfinding"

\end_inset


\end_layout

\begin_layout Standard
Pathfinding rules dictate what happens during agents' movement phases.
 It is here that navigation to objects is described, as well as how avoidance
 logic functions.
\end_layout

\begin_layout Subsubsection
Following targets
\end_layout

\begin_layout Standard
The logic used to follow targets, whether agents or other entities, is quite
 straightforward: turn to face the goal and advance; if the target cannot
 be seen, just go straight, since the current direction was its last-known
 location; if going straight is impossible, pick a random direction no more
 than 90 degrees from the current heading and go that way.
\end_layout

\begin_layout Standard

\series bold
Movement logic
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize},language=Python"
inline false
status collapsed

\begin_layout Standard

i = agent_being_evaluated
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

if i.target in i.agentsInLoS():
\end_layout

\begin_layout Standard

 i.face(i.target)
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

if not i.advance(): #There's a wall that is blocking progress.
\end_layout

\begin_layout Standard

 i.rotate(random.choice((-45, 45))) #Pick a new direction.
\end_layout

\begin_layout Standard

 i.advance() #Try taking one step in the new direction before ending the
 turn.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Following pheromones
\end_layout

\begin_layout Standard
The logic used to follow pheromones is similar to that used to follow targets:
 keep going straight (since pheromones don't move, the agent does not need
 to realign itself at every step) until the target has been reached; if
 going straight is impossible (because of a wall), the strongest like pheromone
 in the Moore neighbourhood is followed instead.
\end_layout

\begin_layout Standard

\series bold
Movement logic
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize},language=Python"
inline false
status collapsed

\begin_layout Standard

i = agent_being_evaluated
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

if i.target.location == i.location: #Destination reached.
\end_layout

\begin_layout Standard

 if not i.status == ENUMERATIONS.RETURNING:
\end_layout

\begin_layout Standard

  i.status = ENUMERATIONS.WANDERING #Stop following the signal.
\end_layout

\begin_layout Standard

 else:
\end_layout

\begin_layout Standard

  i.status = ENUMERATIONS.RETURNING #If the unt was using this as a guide,
 go back to returning.
\end_layout

\begin_layout Standard

elif not i.advance(): #There's a wall that is blocking progress.
\end_layout

\begin_layout Standard

 i.follow(strongestSignal([signal <- i.signalsInMoore() | signalType(signal)
 == 
\backslash

\end_layout

\begin_layout Standard

  signalType(i.target)])) #Follow the strongest close signal.
\end_layout

\begin_layout Standard

  i.advance() #Walk to the new target.
\end_layout

\begin_layout Standard

  i.status = ENUMERATIONS.WANDERING #New target reached.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Wandering randomly
\end_layout

\begin_layout Standard
When wandering, agents will go straight with a 
\begin_inset Formula $ENVIRONMENT_{WANDER.VARIANCE}$
\end_inset

 probability of turning 45 degrees to either side with each step.
 This process will continue unless a wall is hit or the agent is no longer
 wandering.
\end_layout

\begin_layout Standard

\series bold
Movement logic
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize},language=Python"
inline false
status collapsed

\begin_layout Standard

i = agent_being_evaluated
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

if random.random() < ENVIRONMENT.WANDER_VARIANCE: #Decide whether to turn.
\end_layout

\begin_layout Standard

 i.rotate(random.choice((-45, 45)))
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

i.advance()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
When a wall is encountered during an 
\begin_inset listings
lstparams "language=Python"
inline true
status collapsed

\begin_layout Standard

advance()
\end_layout

\end_inset

, agents will randomly choose a new direction in which to travel, though
 workers will behave slightly differently because it is not in their interest
 to head back towards their colony if avoiding it is at all possible.
\end_layout

\begin_layout Standard

\series bold
Wall-collision logic
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize},language=Python"
inline false
status collapsed

\begin_layout Standard

i = agent_being_evaluated
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

paths = [space <- i.spacesInMoore() | isOpen(space)] #Survey the area.
\end_layout

\begin_layout Standard

if isWorker(i):
\end_layout

\begin_layout Standard

 paths = [space <- paths | 
\backslash

\end_layout

\begin_layout Standard

  abs(angleOffset(i, space) - angleOffset(i, i.departed_hill)) > 45] #Try
 to move laterally.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

if paths: #Randomly choose one.
\end_layout

\begin_layout Standard

 i.rotate(angleOffset(i, random.choice(paths)))
\end_layout

\begin_layout Standard

else:
\end_layout

\begin_layout Standard

 i.rotate(180) #Go backwards.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Wandering while avoiding objects
\end_layout

\begin_layout Standard
When an agent is trying to avoid an object (always the closest one to it,
 at least in the early stages of implementation), it will attempt to maintain
 at least the same distance from it after moving that it held prior to moving
 -- it will either move away from it, or try to move in a circular ring
 around it.
 Workers that are avoiding an object, like a threat, will scatter and become
 disoriented until the threat passes; this can cause major changes in supply
 chains -- changes that have the potential to be very interesting.
\end_layout

\begin_layout Standard

\series bold
Movement logic
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize},language=Python"
inline false
status collapsed

\begin_layout Standard

i = agent_being_evaluated
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

paths = [space <- i.spacesInMoore() | isOpen(space), 
\backslash

\end_layout

\begin_layout Standard

 abs(angleOffset(i, space) - angleOffset(i, nearest(i, i.avoid))) > 45] #Move
 laterally.
\end_layout

\begin_layout Standard

if paths: #Pick one to take.
\end_layout

\begin_layout Standard

 i.rotate(angleOffset(i, random.choice(paths))
\end_layout

\begin_layout Standard

else: #Impossible to get away, so try to move past the object at an angle.
\end_layout

\begin_layout Standard

 risky_paths = [space <- i.spacesInMoore() | isOpen(space), angleOffset(i,
 space) in (135, 225)]
\end_layout

\begin_layout Standard

 if risky_paths: #Pick one to take.
\end_layout

\begin_layout Standard

  i.rotate(angleOffset(i, random.choice(risky_paths)))
\end_layout

\begin_layout Standard

 else: #The only path open leads to the object that must be avoided.
\end_layout

\begin_layout Standard

  return #Stay put and hope a path opens.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

i.advance()
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Returning to the colony
\end_layout

\begin_layout Standard
When an unt starts its return trek, it will turn to face the nearest hill
 (don't ask how it knows where that is; it just knows).
 It will then proceed to move in a straight line as far as possible, stopping
 only if it hits a wall.
 Upon recovering, it continues towards the nearest hill from its new location.
\end_layout

\begin_layout Standard

\series bold
Movement logic
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize},language=Python"
inline false
status collapsed

\begin_layout Standard

i = agent_being_evaluated
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

if i.state == ENUMERATIONS.DETOURING:
\end_layout

\begin_layout Standard

 nearest_hill = i.locateNearestHill()
\end_layout

\begin_layout Standard

 if clearPath(i, nearest_hill): #No obstacles in the way.
\end_layout

\begin_layout Standard

  i.rotate(angleOffset(i, nearest_hill)) #Change trajectory.
\end_layout

\begin_layout Standard

 else:
\end_layout

\begin_layout Standard

  nearby_signals = [signal <- i.signalsInLoS() | signalType(signal) in (ENUMERATI
ONS.FOOD, ENUMERATIONS.WATER), 
\backslash

\end_layout

\begin_layout Standard

   -45 <= angleOffset(i, signal) <= 45]
\end_layout

\begin_layout Standard

  if nearby_signals:
\end_layout

\begin_layout Standard

   #Other paths are nearby (in front of the unt, to avoid backtracking),
\end_layout

\begin_layout Standard

   #so use their location as a guide.
\end_layout

\begin_layout Standard

   i.follow(strongestSignal(nearby_signals))
\end_layout

\begin_layout Standard

elif i.state == ENUMERATIONS.BACKTRACKING: #Stop backtracking ASAP.
\end_layout

\begin_layout Standard

 directions = [space <- i.spacesInMoore() | isOpen(space), angleOffset(i,
 space) not in (0, 180)]
\end_layout

\begin_layout Standard

 if directions: #It's possible to change course, so do it.
\end_layout

\begin_layout Standard

  i.rotate(angleOffset(i, random.choice(directions)))
\end_layout

\begin_layout Standard

  i.state = ENUMERATIONS.DETOURING
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard

i.advance()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
When a wall is encountered during an 
\begin_inset listings
lstparams "language=Python"
inline true
status collapsed

\begin_layout Standard

advance()
\end_layout

\end_inset

, the unt will make a decision.
 The outcome will determine how it tries to find a path back to its colony.
\end_layout

\begin_layout Standard

\series bold
Wall-collision logic
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize},language=Python"
inline false
status collapsed

\begin_layout Standard

fork_paths = [space <- i.spacesInMoore() | isOpen(space), -90 < angleOffset(i,
 space) < 90]
\end_layout

\begin_layout Standard

if fork_paths: #Try to go as straight as possible.
\end_layout

\begin_layout Standard

 i.rotate(angleOffset(i, random.choice(fork_paths)))
\end_layout

\begin_layout Standard

 i.state = ENUMERATIONS.DETOURING
\end_layout

\begin_layout Standard

else:
\end_layout

\begin_layout Standard

 directions = [space <- i.spacesInMoore() | isOpen(space), not angleOffset(i,
 space) == 180]
\end_layout

\begin_layout Standard

 if directions: #Go any way possible.
\end_layout

\begin_layout Standard

  i.rotate(angleOffset(i, random.choice(directions)))
\end_layout

\begin_layout Standard

  i.state = ENUMERATIONS.DETOURING
\end_layout

\begin_layout Standard

 else: #Go backwards; this is a dead end.
\end_layout

\begin_layout Standard

  i.rotate(180)
\end_layout

\begin_layout Standard

  i.state = ENUMERATIONS.BACKTRACKING
\end_layout

\end_inset


\end_layout

\begin_layout Section
Environmental rules
\end_layout

\begin_layout Standard
This section describes rules that are entirely dependent upon configuration
 parameters and the net result of their interactions over time.
 These rules include such things as how different classes are selected during
 reproduction, and how new hills are established.
 It is here that the emergent properties of the system flourish and come
 together to produce complex, nigh-unpredictable results.
\end_layout

\begin_layout Subsection
Hills and colonies
\end_layout

\begin_layout Standard
A colony is defined as a related collection of independently managed hills.
 Post-instantiation, no parent-child relationship exists between hills.
 To make this property sustainable, each hill will be responsible for raising
 generations of unts that are distributed to suit the environment that surrounds
 it.
\end_layout

\begin_layout Subsubsection
Spawning a new generation
\end_layout

\begin_layout Standard
A colony may spawn a new generation of unts every time the tick-count 
\begin_inset Formula $colony_{reproduction}$
\end_inset

 reaches 
\begin_inset Formula $0$
\end_inset

, with the quantity of new unts being decided by the following formula:
\begin_inset Formula \[
unts_{new}=min(surplus_{food},surplus_{water})*colony_{population}\]

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $surplus_{food}=(colony_{food:available}-\sum colony_{untz_{consumption:food}})*ENVIRONMENT_{RESOURCES.RESERVE}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $surplus_{water}=(colony_{water:available}-\sum colony_{untz_{consumption:water}})*ENVIRONMENT_{RESOURCES.RESERVE}$
\end_inset


\end_layout

\begin_layout Standard
If the number of new unts is less than 
\begin_inset Formula $ENVIRONMENT{}_{GENERATION.MINIMUM}$
\end_inset

 of the colony's current population, then 
\begin_inset Formula $colony{}_{reproduction}$
\end_inset

 will temporarily be set to 
\begin_inset Formula $ENVIRONMENT_{REPRODUCTION.DELAY}$
\end_inset

, to prevent a colony from imploding when it should just wane a little.
 Else, 
\begin_inset Formula $colony_{reproduction}=ENVIRONMENT_{REPRODUCTION}$
\end_inset

 in preparation for the next cycle.
\end_layout

\begin_layout Subsubsection
Allocating a new generation
\end_layout

\begin_layout Standard
All spawned unts will be initially distributed among their colony's hills
 based on their current populations relative to the population of the colony.
 The following logic will be employed:
\end_layout

\begin_layout Enumerate
Each hill will be assigned a 
\begin_inset Formula $colony_{hill_{priority}}$
\end_inset

 score equal to the result of the following formula, with each variable
 computed since the last spawn:
\begin_inset Formula \[
priority=priority_{control}+priority_{survival}+priority_{race}+priority_{size}\]

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $priority_{control}=ENVIRONMENT_{IMPORTANCE_{EXPANSION}}*colony_{hill_{builders}}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $priority_{survival}=ENVIRONMENT_{IMPORTANCE_{TERRITORY}}*(colony_{hill_{workers:lost}}+colony_{hill_{warriors:lost}})$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $priority_{race}=ENVIRONMENT_{IMPORTANCE_{RESOURCES}}*((colony_{hill_{food:gathered}}/colony_{food:gathered})+(colony_{hill_{water:gathered}}+colony_{water:gathered}))$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $priority_{size}=ENVIRONMENT_{IMPORTANCE_{GROWTH}}*(colony_{population}/colony_{hill_{population}})$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Each hill will receive 
\begin_inset Formula $unts_{assigned}=(colony_{hill_{priority}}/\sum colony_{hills_{priority}})*unts_{new}$
\end_inset

 new unts.
\end_layout

\begin_layout Subsubsection
Assigning classes to a new generation
\begin_inset LatexCommand label
name "sub:Assigning-classes"

\end_inset


\end_layout

\begin_layout Standard
When a hill receives a new generation of unts, each one will be cast into
 a class depending on the needs of the hill.
 The following rules will be applied to determine the class breakdown, with
 each value being counted since the creation of the last generation (resource
 counts are per-return event, not per-unt):
\end_layout

\begin_layout Itemize
\begin_inset Formula $killed=(colony_{hill_{workers:killed}}+colony_{hill_{warriors:killed}})$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $available=unts_{assigned}-killed$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $harvesting=(1-(colony_{hill_{workers:returned.without}}/colony_{hill_{workers:returned}}))*ENVIRONMENT_{colony_{WORKER.GROWTH}}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status inlined

\begin_layout Standard


\backslash
begin{math}
\end_layout

\begin_layout Standard

 insecurity = 
\backslash
left
\backslash
{ 
\backslash
begin{array}{ll}
\end_layout

\begin_layout Standard

  safe & 
\backslash
textrm{if $killed=0$}
\backslash

\backslash

\end_layout

\begin_layout Standard

  unsafe & 
\backslash
textrm{otherwise}
\end_layout

\begin_layout Standard

 
\backslash
end{array} 
\backslash
right.
\end_layout

\begin_layout Standard


\backslash
end{math}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status inlined

\begin_layout Standard


\backslash
begin{math}
\end_layout

\begin_layout Standard

 safe = 
\backslash
left
\backslash
{ 
\backslash
begin{array}{ll}
\end_layout

\begin_layout Standard

  1 & 
\backslash
textrm{if $colony_{hill_{warriors}}
\backslash
leq colony_{hill_{population}}*$}
\backslash

\backslash

\end_layout

\begin_layout Standard

    & 
\backslash
textrm{   $ENVIRONMENT_{colony_{WARRIOR_{POPULATION.MINIMUM}}}$}
\backslash

\backslash

\end_layout

\begin_layout Standard

  ENVIRONMENT_{colony_{WARRIOR_{DECAY}}} & 
\backslash
textrm{otherwise}
\end_layout

\begin_layout Standard

 
\backslash
end{array} 
\backslash
right.
\end_layout

\begin_layout Standard


\backslash
end{math}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $unsafe=ENVIRONMENT_{colony_{WARRIOR_{GROWTH}}}+(killed/(colony_{hill_{workers}}+colony_{hill_{warriors}}+killed))$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $target_{workers}=harvesting*colony_{hill_{workers:lastgen}}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $target_{warriors}=insecurity*colony_{hill_{warriors:lastgen}}$
\end_inset


\end_layout

\begin_layout Itemize
if 
\begin_inset Formula $target_{workers}+target_{warriors}\leq available$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $unts_{workers}=colony_{hill_{workers:killed}}+target_{workers}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $unts_{warriors}=colony_{hill_{warriors:killed}}+target_{warriors}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $unts_{builders}=available-unts_{workers}-unts_{warriors}$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
else:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $unts_{workers}=colony_{hill_{workers:killed}}+available*(target_{workers}/(target_{workers}+target_{warriors}))$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $unts_{warriors}=colony_{hill_{warriors:killed}}+available*(target_{warriors}/(target_{workers}+target_{warriors}))$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $unts_{builders}=0$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
If the number of unts being replaced due to unnatural death exceeds the
 number of new unts being added, the new ones will be allocated proportionally
 between workers and warriors, with no unts cast into other classes.
 The numbers cast in this case follows:
\end_layout

\begin_layout Itemize
\begin_inset Formula $unts_{workers}=unts_{new}*(colony_{hill_{workers:killed}}/(colony_{hill_{workers:killed}}+colony_{hill_{warriors:killed}}))$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $unts_{warriors}=unts_{new}*(colony_{hill_{warriors:killed}}/(colony_{hill_{workers:killed}}+colony_{hill_{warriors:killed}}))$
\end_inset


\end_layout

\begin_layout Subsubsection
Expansion
\begin_inset LatexCommand label
name "sub:Expansion"

\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset Formula $colony_{hill_{unts:builders}}\geq ENVIRONMENT_{colony_{ARCHITECT_{SPAWINING.BUILDER.RATIO}}}*colony_{hill_{population}}$
\end_inset

, then the hill will spawn an architect independently of the other units
 it raises; only one architect may exist per hill at any given time.
 Architects are not guaranteed to find a suitable building site before they
 expire and, in fact, may never find such a site if they come from the middle
 of a well-established colony.
\end_layout

\begin_layout Standard

\newpage

\end_layout

\begin_layout Section
\start_of_appendix
Configuration variables
\end_layout

\begin_layout Subsection
Global environment variables (
\begin_inset Formula $ENVIRONMENT$
\end_inset

)
\end_layout

\begin_layout Subsubsection
General
\end_layout

\begin_layout Standard
\begin_inset Formula $MIN.BUILD.DISTANCE=100$
\end_inset


\end_layout

\begin_layout Subsubsection
Pathfinding
\end_layout

\begin_layout Standard
\begin_inset Formula $WANDER.VARIANCE=0.1$
\end_inset


\end_layout

\begin_layout Subsubsection
Reproduction
\end_layout

\begin_layout Standard
\begin_inset Formula $GENERATION.MINIMUM=0.25$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $IMPORTANCE_{EXPANSION}=0.5$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $IMPORTANCE_{GROWTH}=0.25$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $IMPORTANCE_{RESOURCES}=1.0$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $IMPORTANCE_{TERRITORY}=0.5$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $REPRODUCTION=10,000$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $REPRODUCTION.DELAY=1,000$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $RESOURCES.RESERVE=0.15$
\end_inset


\end_layout

\begin_layout Subsubsection
Signals
\end_layout

\begin_layout Standard
\begin_inset Formula $SIGNALS_{DISPERSION.FACTOR}=0.75$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $SIGNALS_{SPREAD.FACTOR.NEUMANN}=0.5$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $SIGNALS_{SPREAD.FACTOR.MOORE}=0.33$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $SIGNALS_{COLLISION.FACTOR}=0.1$
\end_inset


\end_layout

\begin_layout Subsection
Colony-specific environment variables (
\begin_inset Formula $ENVIRONMENT_{colony}$
\end_inset

)
\end_layout

\begin_layout Subsubsection
General
\end_layout

\begin_layout Standard
\begin_inset Formula $PHEREMONES=75$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $PHEREMONES.ATTACK=100$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $LIFESPAN=ENVIRONMENT+2,500$
\end_inset


\end_layout

\begin_layout Subsubsection
Architects (
\begin_inset Formula $ARCHITECT$
\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset Formula $ENERGY=500$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $SPAWNING.BUILDER.RATIO=0.25$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $SIGHT=20$
\end_inset


\end_layout

\begin_layout Subsubsection
Builders (
\begin_inset Formula $BUILDER$
\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset Formula $CONSUMPTION_{FOOD}=0.75$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $CONSUMPTION_{WATER}=0.75$
\end_inset


\end_layout

\begin_layout Subsubsection
Warriors (
\begin_inset Formula $WARRIOR$
\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset Formula $CONSUMPTION_{FOOD}=1.1$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $CONSUMPTION_{WATER}=1.1$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $DECAY=0.75$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $ENERGY=800$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $ESCORT=0.25$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $GROWTH=1.10$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $POPULATION.MINIMUM=0.1$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $SIGHT=4$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $SMELL=15$
\end_inset


\end_layout

\begin_layout Subsubsection
Workers (
\begin_inset Formula $WORKER$
\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset Formula $BOLDNESS=ENUMERATIONS_{BOLDNESS_{PASSIVE}}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $CARRYING.CAPACITY=10$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $CONSUMPTION_{FOOD}=1$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $CONSUMPTION_{WATER}=1$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $ENERGY=750$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $GROWTH=1.10$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $NO.FOCUS=0.25$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $SIGHT=3$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $SMELL=10$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $STOCHASTIC.PROBABILITY=0.05$
\end_inset


\end_layout

\begin_layout Subsection
Threat-specific environment variables (
\begin_inset Formula $ENVIRONMENT$
\end_inset

)
\end_layout

\begin_layout Subsubsection
Universal (
\begin_inset Formula $THREAT$
\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset Formula $KILL.TIME_{ARCHITECT}=3$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $KILL.TIME_{WARRIOR}=7$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $KILL.TIME_{WORKER}=5$
\end_inset


\end_layout

\begin_layout Subsubsection
Predators (
\begin_inset Formula $PREDATOR$
\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset Formula $HEALTH.POINTS=5$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $NOURISHMENT=3$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $SIGHT=5$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $LIFESPAN=3,000$
\end_inset


\end_layout

\begin_layout Subsubsection
Hunters (
\begin_inset Formula $HUNTERS$
\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset Formula $HEALTH.POINTS=4$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $NOURISHMENT=3$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $PHEREMONES=50$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $SIGHT=4$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $LIFESPAN=2,500$
\end_inset


\end_layout

\begin_layout Subsubsection
Stalkers (
\begin_inset Formula $STALKER$
\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset Formula $HEALTH.POINTS=5$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $NOURISHMENT=3$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $SIGHT=3$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $SMELL=10$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $LIFESPAN=3,000$
\end_inset


\end_layout

\begin_layout Standard

\newpage

\end_layout

\begin_layout Section
Function definitions
\end_layout

\begin_layout Standard
Note: Only functions that need to be explained will be documented here.
\end_layout

\begin_layout Standard
Note: When resolving objects in line-of-sense (LoS), the resulting list
 will always be enumerated in terms of increasing distance.
\end_layout

\begin_layout Subsection
Global functions
\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Standard

int angleOffset(agent, object)
\end_layout

\end_inset

 : returns the number of degrees the agent would need to turn to face the
 object.
\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Standard

bool clearPath(object, object)
\end_layout

\end_inset

 : true if there are no walls on a straight line between the two objects..
\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Standard

bool containsWarrior(list<agent>)
\end_layout

\end_inset

 : true if the provided list contains a warrior unt.
\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Standard

int distance(object, object)
\end_layout

\end_inset

 : computes the distance between two objects.
 If the second object is at the same co-ordinates 
\begin_inset Formula $(x,y)$
\end_inset

 as the first, this is 
\begin_inset Formula $0$
\end_inset

; if 
\begin_inset Formula $abs(x_{1}-x_{2})\leq1$
\end_inset

 and 
\begin_inset Formula $abs(y_{1}-y_{2})\leq1$
\end_inset

, this is 
\begin_inset Formula $1$
\end_inset

; else, this is 
\begin_inset Formula $abs(x_{1}-x_{2})+abs(y_{1}-y_{2})$
\end_inset

 with 
\begin_inset Formula $1$
\end_inset

 subtracted if 
\begin_inset Formula $abs(x_{1}-x_{2})>0$
\end_inset

 and 
\begin_inset Formula $abs(y_{1}-y_{2})>0$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Standard

bool exists(agent)
\end_layout

\end_inset

 : true if the specified agent is still present on the field.
\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Standard

bool exists(signal)
\end_layout

\end_inset

 : true if the space occupied by the signal still contains the signal's
 pheromone type.
\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Standard

bool isAgent(object)
\end_layout

\end_inset

 : true if the object referenced is an instance of an agent.
\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Standard

bool isOpen(space)
\end_layout

\end_inset

 : true if the space specified is open.
\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Standard

bool isSignal(object)
\end_layout

\end_inset

 : true if the object referenced is an instance of a signal.
\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Standard

bool isThreat(agent, agent)
\end_layout

\end_inset

 : true if the second agent is a threat to the first one.
\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Standard

bool isUnt(agent)
\end_layout

\end_inset

 : true if the agent specified is an unt.
\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Standard

bool isWarrior(agent)
\end_layout

\end_inset

 : true if the agent specified is a warrior unt.
\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Standard

type resourceType(resource)
\end_layout

\end_inset

 : returns the type of the specified resources.
\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Standard

int signalStrength(location, type, colony=None)
\end_layout

\end_inset

 : returns the strength of the specified type of pheromone at the specified
 location.
 colony, if specified, serves to filter the signals evaluated.
\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Standard

type signalType(signal)
\end_layout

\end_inset

 : returns the pheromone type of the specified signal.
\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Standard

signal strongestSignal(list<signal>)
\end_layout

\end_inset

 : returns the strongest signal in the provided list.
\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Standard

signal weakestSignal(list<signal>)
\end_layout

\end_inset

 : returns the weakest signal in the provided list.
\end_layout

\begin_layout Subsection
Agent functions
\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Standard

bool advance()
\end_layout

\end_inset

 : causes the agent to walk one space forward along its current heading;
 success is returned.
\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Standard

list<agent> agentsInLoS()
\end_layout

\end_inset

 : builds a list of all agents within the active agent's line of sight,
 ordered by proximity.
\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Standard

void attack(agent)
\end_layout

\end_inset

 : causes the agent to attack the target, inflicting damage or killing it,
 while also taking appropriate damage itself.
\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Standard

void avoid(object)
\end_layout

\end_inset

 : causes the agent to add the object to the list of things it needs to
 stay away from.
\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Standard

bool canSense(agent)
\end_layout

\end_inset

 : true if the specified agent is in the active agent's line of sight.
\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Standard

bool canSense(signal)
\end_layout

\end_inset

 : true if the space occupied by the signal still contains the signal's
 pheromone type and the space is in the active agent's line of smell.
\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Standard

void follow(object)
\end_layout

\end_inset

 : causes the agent to turn directly towards the specified object, sets
 the object as the agent's 
\begin_inset Formula $target$
\end_inset

, and sets the agent's 
\begin_inset Formula $status$
\end_inset

 to 
\begin_inset Formula $ENUMERATIONS_{FOLLOWING}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Standard

bool harvest(resource)
\end_layout

\end_inset

 : causes the agent to harvest the specified resource, and sets the resource
 type as the agent's 
\begin_inset Formula $carrying$
\end_inset

.
 If it fails because the resource is depleted, 
\begin_inset Formula $carrying$
\end_inset

 isn't set and false is returned.
\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Standard

hill locateNearestHill()
\end_layout

\end_inset

 : locates the hill closest to the agent that belongs to the agent's colony.
\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Standard

void move()
\end_layout

\end_inset

 : initiates pathfinding logic.
\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Standard

void producePheremone(type)
\end_layout

\end_inset

 : causes the agent to deposit pheromones of the specified type at its current
 location.
\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Standard

list<resource> resourcesInLoS()
\end_layout

\end_inset

 : builds a list of all resources within the active agent's line of sight,
 ordered by proximity.
\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Standard

list<signal> signalsInLoS()
\end_layout

\end_inset

 : builds a list of all signals within the active agent's line of smell,
 ordered by proximity.
\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Standard

list<signal> signalsInMoore()
\end_layout

\end_inset

 : builds a list of all signals within the active agent's Moore neighbourhood,
 with signals returned in strictly random order.
\end_layout

\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Standard

list<space> spacesInMoore()
\end_layout

\end_inset

 : builds a list of all spaces within the active agent's Moore neighbourhood,
 with spaces returned in strictly random order.
\end_layout

\end_body
\end_document
